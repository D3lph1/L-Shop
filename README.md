# L-Shop
Laravel, Vue

Нашел интересный проект с точки зрения архитектуры. Буду его комментировать на русском и разбирать на части. Думаю, что когда-нибудь мне понадобятся знания по устройству таких проектов
Проект выбран, посольку в нем очень хороший SOLID, паттерны, работа через IoC

Считаю что таким приложением можно погордиться. Это Майнкрафтовский ЛЕГО. Весь потенциал SOLID

Что хорошеее в приложении:
1. Хорошая организация классов. Видно что они хорошо соответствуют принципу единственной ответственности. В процессе Active Record были заменены на ORM Doctrine. 
Хотя сильная привязка к ОРМ осталась в виде аннотаций Doctrine, что по сути также нарушает принцип единственной ответственности. Хотя эти классы Entity связаны исключительно с репозиториями. 
     /**
      * Category identifier.
      *
      * @ORM\Id
      * @ORM\Column(name="id", type="integer")
      * @ORM\GeneratedValue(strategy="AUTO")
      */
     private $id;
Для манипуляции с объектами имеются дополнительные уровни классов.

2. Хорошее соблюдение принципа инверсии зависимостей. Большая часть кода верхних и нижних уровней реализована в виде сервисов. По сути слои кода=сервисы. Связываются слои кода след образом:
          public function __construct(UserRepository $userRepository, EntityManagerInterface $em, Hasher $hasher)
          {
              $this->userRepository = $userRepository;
              $this->em = $em;
              $this->hasher = $hasher;
          }
В конструкторы или методы вызываемые фреймворком Laravel через разные механизмы IoC, вызов handle() приходят объекты из IoC. Либо передача сущностей  в конструкторы происходит  в пользовательском коде.
Тут главное, что нужно понимать, что слои   
    
3. Методы работы с БД заключены в репозиториях. Репозитории тоже доступны через сервисы, которые регистрируются провайдером RepositoryServiceProvider.
При организации репозиторий хорошо соблюден принцип разделения интерфейсов, который гласит, что клиенты не должны зависеть от методов, которые они не используют.
Реализовано это присутствием интерфейса к кажому репозиторию. Например, DoctrineActivationRepository реализует интерфейс  ActivationRepository.
DoctrineActivationRepository необходим для работы с БД через Doctrine. Предполагается что репозитории могут в дальнейшем расширяться.
Глядя на репозитории можно разглядеть и соблюдение принципа открытости/закрытости, потому что интерфейс есть и мы всегда можем добавить новый репозиторий.

4. В директории app/Handlers расположены обработчики запросов, команды. Непосредственное исполнение запросов реализуется в Handelr-обработчиках.
Сделано это также в целях разделения кода и ответственности.  Handlers тоже доступны как сервисы. То есть в контроллерах такого вида короткий код:
  public function add(AddEditRequest $request, AddHandler $handler): JsonResponse
    {
        $handler->handle(new Add($request->get('title'), $request->get('content')));

        return (new JsonResponse(Status::SUCCESS))
            ->addNotification(new Success(__('msg.admin.news.add.success')));
    }

5. В папке DataTransferObjects  расположены классы, которые предназанчены для перевода, перемещения. Передачи объектов осуществляются в 2 стороны. Там 2 типа классов: 
    a)Для сериализации объектов для API и конвертации в JSON. Это промежуточные классы между JSON и объектами программы
    b)Для передачи объектов из кода контроллеров в Handlers-обработчики. Связано это с желанием ввода дополнительного уровня объектов наравне с Requests 

6. Таким образом объекты сущностей, которыми манипулирует данный проект разделены на:
    a) Requests, которые приходят на экшен
    b) DataTransferObjects для передачи данных в программе
    c) Entity для удобной работы с БД, что по сути ActiveRecords