# L-Shop
Технологии  - Laravel, Vue

Интересный проект с точки зрения архитектуры. Буду его комментировать на русском и разбирать на части.
Проект выбран, посольку в нем очень хороший SOLID, паттерны, работа через IoC

Что хорошеее в приложении:
1. Хорошая организация классов. Видно что они хорошо соответствуют принципу единственной ответственности. В процессе Active Record были заменены на ORM Doctrine. 
Хотя сильная привязка к ОРМ осталась в виде аннотаций Doctrine, что по сути также нарушает принцип единственной ответственности. Хотя эти классы Entity связаны исключительно с репозиториями. 
   ````
     /**
      * Category identifier.
      *
      * @ORM\Id
      * @ORM\Column(name="id", type="integer")
      * @ORM\GeneratedValue(strategy="AUTO")
      */
     private $id;
   ```` 
   Для манипуляции с объектами имеются дополнительные уровни классов.

2. Хорошее соблюдение принципа инверсии зависимостей. Большая часть кода верхних и нижних уровней реализована в виде сервисов. По сути слои кода=сервисы. Связываются слои кода след образом:
   ````
      public function __construct(UserRepository $userRepository, EntityManagerInterface $em, Hasher $hasher)
      {
         $this->userRepository = $userRepository;
         $this->em = $em;
         $this->hasher = $hasher;
      }
   ````   
   В конструкторы или методы вызываемые фреймворком Laravel через разные механизмы IoC, вызов handle() приходят объекты из IoC. Либо передача сущностей  в конструкторы происходит  в пользовательском коде. 
    
3. Методы работы с БД заключены в репозиториях. Репозитории тоже доступны через сервисы, которые регистрируются провайдером RepositoryServiceProvider.
При организации репозиторий хорошо соблюден принцип разделения интерфейсов, который гласит, что клиенты не должны зависеть от методов, которые они не используют.
Реализовано это присутствием интерфейса к кажому репозиторию. Например, DoctrineActivationRepository реализует интерфейс  ActivationRepository.
DoctrineActivationRepository необходим для работы с БД через Doctrine. Предполагается что репозитории могут в дальнейшем расширяться.
Глядя на репозитории можно разглядеть и соблюдение принципа открытости/закрытости, потому что интерфейс есть и мы всегда можем добавить новый репозиторий.

4. В директории app/Handlers расположены обработчики запросов, команды. Непосредственное исполнение запросов реализуется в Handelr-обработчиках.
Сделано это также в целях разделения кода и ответственности.  Handlers тоже доступны как сервисы. То есть в контроллерах такого вида короткий код:
     ````
     public function add(AddEditRequest $request, AddHandler $handler): JsonResponse
     {
        $handler->handle(new Add($request->get('title'), $request->get('content')));

        return (new JsonResponse(Status::SUCCESS))
            ->addNotification(new Success(__('msg.admin.news.add.success')));
     }
      ````

5. В папке DataTransferObjects  расположены классы, которые предназанчены для перевода, перемещения. Передачи объектов осуществляются в 2 стороны. Там 2 типа классов: 
    - Для сериализации объектов для API и конвертации в JSON. Это промежуточные классы между JSON и объектами программы;
    - Для передачи объектов из кода контроллеров в Handlers-обработчики. Связано это с желанием ввода дополнительного уровня объектов наравне с Requests;

6. Таким образом объекты сущностей, которыми манипулирует данный проект разделены на:
    - Requests, которые приходят на экшен;
    - DataTransferObjects для передачи данных в программе;
    - Entity для удобной работы с БД, что по сути ActiveRecords;
    
7. Имеются команды в проекте, которые также используют сервисы:
    ````
    public function handle(CompleteHandler $handler): int
    ````    
8. Имеется папка Composers. Там по сути 2 типа класса:
    - AdminBlockConstructor - реализующий паттерн composers для хранения разнотипных данных и ссылок на внешние ресурсы
    - GlobalLayoutComposer - для композеров шаблонов, передачи переменных в шаблон
    
9. Имеется папка Events, в котором хранятся события. Они связаны напрямую с Entity Doctrine иногда

10. По проекту можно кратко о сервисах сказать так. Имеются много-много сервисов и связывай их с кем хочешь

11. Тестирование проекта:
Тестирование проекта основана на транзакциях и откатах для очитки результатов добавления. Регистрация сервисов также происходит в тестах в коде. Тут на мой взгляд можно было реализовать настройкой конфигурационных файлов тестов.
Порядок тестов следующий:
    - Регистрируются сервисы
    - Создается транзакция
    - Исполняется тестируемый функционал
    - Проверка Asserts
    - Откат транзакции в целях вычищения ненужных объектов    
Интересно, на какой базе исполняются такие тесты. Мне кажется они и на проде ничего не поломают. Универсальные тесты
